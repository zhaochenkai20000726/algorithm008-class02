学习笔记
递归
递归(Recursion)是指在函数的定义中使用函数自身的方法。递归的使用条件为：存在一个递归调用的终止条件；每次递归的调用必须越来越靠近这个条件；只有这样递归才会终止，否则不能使用递归（陷入死循环导致栈溢出错误）。一般递归都是类似下面的递归模板代码。

public void recur(int level, int param) { 
  // terminator 递归终结条件
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }
  // process current logic 处理当前层逻辑
  process(level, param); 
  // drill down 下探到下一层
  recur( level: level + 1, newParam); 
  // restore current status 如有需要，清理当前层 
}
树的面试题解法一般都是递归，因为

1. 结点的定义就是以递归方式进行
2. 重复性（自相似性）
二叉搜索树：左子树小于根节点，右子树大于根节点，且左右子树具有相同特征
分治
分治法设计思想： 1、将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解； 2、解决问题所需的计算时间都与其规模有关，问题的规模越小，越容易求解，所需的计算时间也越少。分治法就是将一个难以解决的大规模的问题，拆分成规模小且所需计算时间少的相同问题，分别解决； 3、许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归的调用其自身以解决紧密相关的若干子问题（如：归并排序、快速排序、二分搜索等）。这些算法典型的采用了分治法的设计思想；

分治法步骤： 1、分解原问题为若干子问题，这些子问题是原问题的规模较小的实例； 2、解决这些子问题，递归地求解各子问题。如果子问题的规模足够小，则直接求解； 3、合并这些子问题的解成原问题的解（如果子问题是不独立的，紧密则会导致重复求解相同的子问题，会降低分治法效率，一般会采用动态规划）；

回溯
回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

参考链接：https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/

解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：

def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。